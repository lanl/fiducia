# -*- coding: utf-8 -*-
"""
Created on Thu Apr 17 07:49:29 2025

@author: Daniel H Barnak
"""
# python modules
import numpy as np
import scipy.sparse as sparse
from scipy import integrate
from scipy.interpolate import pchip_interpolate as pchip
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import xarray as xr
import pandas as pd
# custom modules
import fiducia.pltDefaults
import fiducia.loader
from fiducia.stats import dotVariance
from fiducia.loader import signalsAtTime
from numba import jit
# listing all functions declared in this file so that sphinx-automodapi
# correctly documents them and doesn't document imported functions.
__all__ = ["linespline",
           "minFunc",
           "knotSolvePCHIP",
           "pchip_1d",
           "minFunc_jit",
           "neldermead",
           "linespline_jit",
           "get_errors",
           "get_responses",
           "checkFidelity_jit",
           "responseArrayMC",
           "MC_jit",
           "run_MC_wrapper"
           ]

def linespline(signals,
               responseFrame, 
               channels, 
               knots,
               plot=False):
    """
    A direct inversion solver that esitmates the average x-ray flux for each
    channel interval (space between k-edges). This provides appropriate initial
    conditions for the Nelder-Mead solver. This is also a good checker to use
    to see if the unfold will be successful or not.

    Parameters
    ----------
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    channels: list, numpy.ndarray
        List or array of relevant channels.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    plot: Bool
        When True, plots the resulting spline values. The default is False.

    Returns
    -------
    linespline : numpy.ndarray
        The resulting spline values that represent the average x-ray flux for
        the energy band between response k-edges.

    """
    
    # integrate channel responses to build response matrix
    linesplineTab = np.zeros((len(channels), len(knots)-1))
    for idx, chan in enumerate(channels):
        energy = responseFrame["Energy(eV)"]
        toIntegrate = responseFrame[chan]
        for idx2 in range(0, len(knots)-1):
            lb = knots[idx2]
            rb = knots[idx2 + 1]
            uInterp = np.arange(lb, rb, 0.001)
            pchipResponse = pchip(energy, toIntegrate, uInterp)
            integResponse = np.trapz(pchipResponse, uInterp)
            # interpResp = np.interp(uInterp, energy, toIntegrate)
            # integResponse = np.trapz(interpResp, uInterp)
            linesplineTab[idx, idx2] = integResponse
    # take the inverse of the integrated response matrix
    lineInverse = np.linalg.inv(linesplineTab)
    # take dot product and clip solution to positive values
    dotProd = np.dot(lineInverse, signals)
    linespline = np.clip(dotProd, 0, np.inf)
    # plot the result of each time step
    if plot == True:
        # plt.figure(idx)
        plt.plot(knots[1:], linespline, )
        plt.title("linear spline solution")
        plt.show()
            
    return linespline

def minFunc(yKnotVals,
            responseFrame,
            chanUsed,
            knots,
            voltages,
            y0, 
            xInterp = 'default'):
    """
    Minimization function that the Nelder-Mead solver uses to do the unfold.

    Parameters
    ----------
    yKnotVals: numpy.ndarray
        Array of knot point intensity values with yGuess appended.
        See knotSolvePCHIP().
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    chanUsed : list, numpy.ndarray
        List or array of channels used in the unfold.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    voltages : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    y0 : float
        The initial value of the spline. Typically this is a guess formulated
        from 1) knowing roughly what the x-ray flux is in the first channel
        band or 2) estimated from the linespline result.
    xInterp : str, optional
        Specifies the number of points to be used in the PCHIP interpolation of
        knots (energies) and knotValues (fluxes). The default is 'default'.

    Returns
    -------
    residual : numpy.ndarray
        The square root of the sum of square differences between the input 
        voltages and the spline solution convovled with the response functions.
        This the function to be minimized, so successful unfolds will yield an
        array of values close to zero.

    """
    solution = np.zeros_like(chanUsed, dtype="float64")
    yKnotValsGuess = np.insert(yKnotVals, 0, y0)
    if xInterp == "default":
        interpLen = responseFrame.shape[0]*10
        xInterp = np.linspace(min(knots), max(knots), num = interpLen)
    for idx, chan in enumerate(chanUsed):
        # print(chan, interpLen)
        pchipSol = pchip(knots, yKnotValsGuess, xInterp)
        pchipResp = pchip(responseFrame["Energy(eV)"],
                          responseFrame[chan],
                          xInterp)
        convolve = pchipResp*pchipSol
        integCon = np.trapz(convolve, xInterp)
        solution[idx] = integCon
    residual = np.sum((solution-voltages)**2)**(1/2)
    
    return residual

def knotSolvePCHIP(signals,
                   responseFrame, 
                   channels, 
                   knots,
                   initial = [],
                   xInterp = 'default',
                   plot=False):
    """
    Function that performs the Dante unfold using PCHIP interpolation and
    least-squares minimization rather than direct inversion. This method is
    constrained to only produce positive values of x-ray flux unlike
    knotSolve(). For faster unfolds, see the jitted (Numba) version 
    knotSolvePCHIP_jit().

    Parameters
    ----------
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    channels: list, numpy.ndarray
        List or array of relevant channels
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    initial : list, optional 
        The initial point used in the Nelder-Mead simplex. This initial value
        is calculated automatically via the linespline() function if left
        empty. The user is free to specify this initial point independently,
        but typically the guess won't be as good as the linear spline estimate.
        The default is [].
    xInterp : str, optional
        Specifies the number of points to be used in the PCHIP interpolation of
        knots (energies) and knotValues (fluxes). The default is 'default'.
    plot: Bool
        When True, plots the resulting PCHIP-interpolated x-ray flux. The 
        default is False.

    Returns
    -------
    knotsY : numpy.ndarray
        The y-values of the x-ray flux at each knot point (energy/k-edge 
        locations). Use these values as the y input and knots as the x
        input to the PCHIP interpolater to get the x-ray flux curve..

    """
    
    # solve linear spline first to provide seeding for Nelder-Mead simplex
    if len(initial) == 0:
        Linespline = linespline(signals=signals,
                                responseFrame=responseFrame,
                                channels=channels,
                                knots=knots,
                                plot=plot)
    else:
        Linespline = initial
    
    # initial point guess based upon initial linear spline point
    y0 = Linespline[0]*1e-1

    # list of bounds. Accept only physical soltuions (knotsY>0)
    bounds = [(0, np.inf) for _ in range(len(channels))]
    
    # run minimization using Nelder-Mead and scipy minimize function
    fiduciaSolve = minimize(minFunc,
                            Linespline,
                            args = (responseFrame,
                                    channels,
                                    knots,
                                    signals,
                                    y0,
                                    xInterp),
                            method = "Nelder-Mead",
                            bounds = bounds,
                            tol = 1e-6,
                            options = {'maxiter' : 600})
    
    # return knot values from minimization
    knotsY = np.insert(fiduciaSolve.x, 0, y0)
    
    # reconstruct the spline solution using PCHIP with identical interpolation
    if xInterp == "default":
        interpLen = responseFrame.shape[0]*10
        xInterp = np.linspace(min(knots), max(knots), num = interpLen)
    pchipSpline = pchip(knots, knotsY, xInterp)
    
    # plot the spline exact values
    if plot:
        # plt.figure(20)
        plt.plot(xInterp, pchipSpline)
        plt.scatter(knots, knotsY)
        plt.title("PCHIP solution")
        plt.show()
        
    return knotsY

def checkKnots(signals,
               responseFrame, 
               channels, 
               knots,
               knotsY):
    
    # initialize solution array
    fideltiy = np.zeros_like(channels, dtype="float64")
    
    # reconstruct the spline solution using PCHIP with identical interpolation
    interpLen = responseFrame.shape[0]*10
    xInterp = np.linspace(min(knots), max(knots), num = interpLen)
    # pchipSpline = pchip(knots, knotsY, xInterp)
    
    for idx, chan in enumerate(channels):
        # print(chan, interpLen)
        pchipSol = pchip(knots, knotsY, xInterp)
        pchipResp = pchip(responseFrame["Energy(eV)"],
                          responseFrame[chan],
                          xInterp)
        convolve = pchipResp*pchipSol
        integCon = np.trapz(convolve, xInterp)
        fideltiy[idx] = integCon
    return fideltiy

@jit(nopython = True)
def pchip_1d(xData, yData, xInterp, order = 3):
    """
    Jitted function based on SciPy's native PCHIP interpolater. Elimination of
    class architecture allows for easier compiling. Used with all jitted
    functions labeled with _jit.

    Parameters
    ----------
    xData : numpy.ndarray
        X points that fix the interpolant. These would be the knots (energies).
    yData : numpy.ndarray
        Y points to be interpolated.
    xInterp : numpy.ndarray
        X points to be interpolated over.
    order : int, optional
        The integer order of the interpolating polynomial. The default value is
        the only choice as of right now. The default is 3.

    Returns
    -------
    interp : numpy.ndarray
        The resulting y values of the interpolant evaluated at the xInter
        points.

    """
    # xData = knots
    # yData = splineVals
    if yData.ndim == 1:
        # So that _edge_case doesn't end up assigning to scalars
        x = xData[:, None]
        y = yData[:, None]
    hk = x[1:] - x[:-1]
    mk = (y[1:] - y[:-1]) / hk
    
    if y.shape[0] == 2:
        # edge case: only have two points, use linear interpolation
        dk = np.zeros_like(y)
        dk[0] = mk
        dk[1] = mk
        dydx = dk.reshape(y.shape)
    else:
        # needs special handling for jit compatibility and div-by-zero cases
        # still occasionally throws overflows!
        smk = np.sign(mk)
        condition = (smk[1:] != smk[:-1]) | (mk[1:] == 0) | (mk[:-1] == 0)
        boolConv = condition*1
        boolConvNeg = ~condition*1
        w1 = 2*hk[1:] + hk[:-1]
        w2 = hk[1:] + 2*hk[:-1]
        mkNonzero1 = mk[:-1] + boolConv
        mkNonzero2 = mk[1:] + boolConv
        whmean = ((w1/mkNonzero1 + w2/mkNonzero2) / (w1 + w2))
        
        # calculate derivatives of middle points
        dk = np.zeros_like(y)
        # set instances where mk is 0 to 0
        dk[1:-1] = (1.0/whmean)*boolConvNeg
        
        # calculate derivatives of edge points
        # left-most edge
        h0 = hk[0]
        h1 = hk[1]
        m0 = mk[0]
        m1 = mk[1]
        d0 = ((2*h0 + h1)*m0 - h0*m1) / (h0 + h1)
    
        # try to preserve shape
        mask = np.sign(d0) != np.sign(m0)
        mask2 = (np.sign(m0) != np.sign(m1)) & (np.abs(d0) > 3.*np.abs(m0))
        mmm = (~mask) & mask2
    
        d0[mask] = 0.
        d0[mmm] = 3.*m0[mmm]
        dk[0] = d0
        # right-most edge
        h0 = hk[-1]
        h1 = hk[-2]
        m0 = mk[-1]
        m1 = mk[-2]
        d0 = ((2*h0 + h1)*m0 - h0*m1) / (h0 + h1)
    
        # try to preserve shape
        mask = np.sign(d0) != np.sign(m0)
        mask2 = (np.sign(m0) != np.sign(m1)) & (np.abs(d0) > 3.*np.abs(m0))
        mmm = (~mask) & mask2
    
        d0[mask] = 0.
        d0[mmm] = 3.*m0[mmm]
        dk[-1] = d0
        # dk[0] = PchipInterpolator._edge_case(hk[0], hk[1], mk[0], mk[1])
        # dk[-1] = PchipInterpolator._edge_case(hk[-1], hk[-2], mk[-1], mk[-2])
        dydx = dk
    # # Calculate spline coefficients using derivative values
    dx = np.diff(xData)
    dxr = dx[:, None]
    dy = np.diff(yData)
    dyr = dy[:, None]
    slope = dyr / dxr
    t = (dydx[:-1] + dydx[1:] - 2 * slope) / dxr
    
    c = np.empty((4, len(x) - 1) + y.shape[1:], dtype=t.dtype)
    c[0] = t / dxr
    c[1] = (slope - dydx[:-1]) / dxr - t
    c[2] = dydx[:-1]
    c[3] = y[:-1]
    
    # now construct the spline using framework described in Scipy: class PPoly
    k = order # order of the polynomial
    interp = np.array([yData[0]], dtype = "float64")
    # interp = np.empty(0, dtype = "float64")
    for idx, knot in enumerate(xData[:-1]):
        # isolate each segment of the spline
        lowSeg = xData[idx] < xInterp
        upSeg = xInterp <= xData[idx + 1]
        segBool = lowSeg & upSeg
        seg = xInterp[segBool]
        # # construct the spline using sum from scipy PPoly
        c0 = c[0, idx]
        c1 = c[1, idx]
        c2 = c[2, idx]
        c3 = c[3, idx]
        poly = seg - knot
        S = c0*poly**3 + c1*poly**2 + c2*poly + c3
        # S = sum(c[m, idx] * (seg - knot)**(k-m) for m in range(k+1))
        interp = np.append(interp, S)
        
    return interp

@jit(nopython=True, parallel = False)
def minFunc_jit(yKnotVals,
                responseArray,
                knots,
                voltages,
                y0,
                xInterp = 'default'):
    """
    Jitted version of minFunc(). See minFunc().

    Parameters
    ----------
    yKnotVals: numpy.ndarray
        Array of knot point intensity values with yGuess appended.
        See knotSolvePCHIP().
    responseArray: numpy.ndarray
        DANTE channel responses as a function of photon energy (not 
        normalized). Must use numpy arrays here for Numba to compile. See
        get_responses().
    chanUsed : list, numpy.ndarray
        List or array of channels used in the unfold.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    voltages : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    y0 : float
        The initial value of the spline. Typically this is a guess formulated
        from 1) knowing roughly what the x-ray flux is in the first channel
        band or 2) estimated from the linespline result.
    xInterp : str, optional
        Specifies the number of points to be used in the PCHIP interpolation of
        knots (energies) and knotValues (fluxes). The default is 'default'.

    Returns
    -------
    residual : numpy.ndarray
        The square root of the sum of square differences between the input 
        voltages and the spline solution convovled with the response functions.
        This the function to be minimized, so successful unfolds will yield an
        array of values close to zero.

    """
    chanNum = responseArray.shape[1]
    solution = np.zeros(chanNum-1, dtype="float64")
    yKnotValsGuess = np.zeros(len(yKnotVals)+1, dtype="float64")
    yKnotValsGuess[0] = y0
    yKnotValsGuess[1:] = yKnotVals
    if xInterp == "default":
        interpLen = responseArray.shape[0]*10
        xInt = np.linspace(min(knots), max(knots), interpLen)
    for idx in range(chanNum-1):
        pchipSol = pchip_1d(knots, yKnotValsGuess, xInt)
        # pchipResp = pchip_1d(responseArray[:, 0],
        #                       responseArray[:, idx+1],
        #                       xInt)
        interpResp = np.interp(xInt, responseArray[:, 0], responseArray[:, idx+1])
        # convolve = pchipResp*pchipSol
        convolve = interpResp*pchipSol        
        integCon = np.trapz(convolve, xInt)
        solution[idx] = integCon
    residual = np.sum((solution-voltages)**2)**(1/2)
    
    return residual

@jit(nopython = True)
def neldermead(func, x0, args=(),
               maxiter=800, maxfev=np.inf,
               xatol=1e-6, fatol=1e-1, adaptive=False, bounds = None):
    """
    Minimization of scalar function of one or more variables using the
    Nelder-Mead algorithm. Adapted from Scipy to work with numba by DH Barnak.

    Options
    -------
    maxiter, maxfev : int
        Maximum allowed number of iterations and function evaluations.
        Will default to ``N*200``, where ``N`` is the number of
        variables, if neither `maxiter` or `maxfev` is set. If both
        `maxiter` and `maxfev` are set, minimization will stop at the
        first reached.
    initial_simplex : array_like of shape (N + 1, N)
        Initial simplex. If given, overrides `x0`.
        ``initial_simplex[j,:]`` should contain the coordinates of
        the jth vertex of the ``N+1`` vertices in the simplex, where
        ``N`` is the dimension.
    xatol : float, optional
        Absolute error in xopt between iterations that is acceptable for
        convergence.
    fatol : number, optional
        Absolute error in func(xopt) between iterations that is acceptable for
        convergence.
    adaptive : bool, optional
        Adapt algorithm parameters to dimensionality of problem. Useful for
        high-dimensional minimization [1]_.
    bounds : sequence or `Bounds`, optional
        Bounds on variables. There are two ways to specify the bounds:

            1. Instance of `Bounds` class.
            2. Sequence of ``(min, max)`` pairs for each element in `x`. None
               is used to specify no bound.

        Note that this just clips all vertices in simplex based on
        the bounds.

    References
    ----------
    .. [1] Gao, F. and Han, L.
       Implementing the Nelder-Mead simplex algorithm with adaptive
       parameters. 2012. Computational Optimization and Applications.
       51:1, pp. 259-277

    """
    # _check_unknown_options(unknown_options)
    maxfun = maxfev

    x0 = np.asfarray(x0).flatten() #make sure x0 is 1d array of floats
    
    # unjitable class Bounds
    # bounds = standardize_bounds(bounds)

    if adaptive:
        dim = float(len(x0))
        rho = 1
        chi = 1 + 2/dim
        psi = 0.75 - 1/(2*dim)
        sigma = 1 - 1/dim
    else:
        rho = 1
        chi = 2
        psi = 0.5
        sigma = 0.5

    nonzdelt = 0.05
    zdelt = 0.00025

    if bounds is not None:
        # lower_bound, upper_bound = bounds.lb, bounds.ub #old bounds routine
        lower_bound = bounds[:, 0]
        upper_bound = bounds[:, 1]


    if bounds is not None:
        x0 = np.clip(x0, lower_bound, upper_bound)
    # this version does not allow users to supply an initial simplex
    # if initial_simplex is None:
    N = len(x0)
    
    # calculate initial simplex from starting point
    sim = np.empty((N + 1, N), dtype=x0.dtype)
    sim[0] = x0
    for k in range(N):
        # y = np.array(x0, copy=True) #copy array not jit supported
        y = x0
        if y[k] != 0:
            y[k] = (1 + nonzdelt)*y[k]
        else:
            y[k] = zdelt
        sim[k + 1] = y
    # this version does not allow users to supply an initial simplex
    # else:
    #     sim = np.asfarray(initial_simplex).copy()
    #     if sim.ndim != 2 or sim.shape[0] != sim.shape[1] + 1:
    #         raise ValueError("`initial_simplex` should be an array of shape (N+1,N)")
    #     if len(x0) != sim.shape[1]:
    #         raise ValueError("Size of `initial_simplex` is not consistent with `x0`")
    #     N = sim.shape[1]

    # If neither are set, then set both to default
    if maxiter is None and maxfun is None:
        maxiter = N * 200
        maxfun = N * 200
    elif maxiter is None:
        # Convert remaining Nones, to np.inf, unless the other is np.inf, in
        # which case use the default to avoid unbounded iteration
        if maxfun == np.inf:
            maxiter = N * 200
        else:
            maxiter = np.inf
    elif maxfun is None:
        if maxiter == np.inf:
            maxfun = N * 200
        else:
            maxfun = np.inf
    if bounds is not None:
        sim = np.clip(sim, lower_bound, upper_bound)
    one2np1 = list(range(1, N + 1))
    fsim = np.full((N + 1,), np.inf, dtype=float)
    # # fcalls, func = _wrap_scalar_function_maxfun_validation(func, args, maxfun)

    for k in range(N + 1):
        fsim[k] = func(sim[k], args[0], args[1], args[2], args[3])
    ind = np.argsort(fsim)
    fsim = np.take(fsim, ind)
    # # fsim = np.sort(fsim)
    # # # sort so sim[0,:] has the lowest function value
    # sim = np.take(sim, ind, 0)
    sim = sim[ind]
    # # sim = np.sort(sim)
    
    iterations = 1
    # while (fcalls[0] < maxfun and iterations < maxiter):
    while (iterations < maxiter):
            if (np.max(np.ravel(np.abs(sim[1:] - sim[0]))) <= xatol or
                    np.max(np.abs(fsim[0] - fsim[1:])) <= fatol):
                print("break from xatol fatol")
                break

            # xbar = np.add.reduce(sim[:-1], 0) / N
            xbar = np.sum(sim[:-1], 0) / N
            xr = (1 + rho) * xbar - rho * sim[-1]
            if bounds is not None:
                xr = np.clip(xr, lower_bound, upper_bound)
            # fxr = func(xr)
            fxr = func(xr, args[0], args[1], args[2], args[3])
            doshrink = 0

            if fxr < fsim[0]:
                xe = (1 + rho * chi) * xbar - rho * chi * sim[-1]
                if bounds is not None:
                    xe = np.clip(xe, lower_bound, upper_bound)
                # fxe = func(xe)
                fxe = func(xe, args[0], args[1], args[2], args[3])

                if fxe < fxr:
                    sim[-1] = xe
                    fsim[-1] = fxe
                else:
                    sim[-1] = xr
                    fsim[-1] = fxr
            else:  # fsim[0] <= fxr
                if fxr < fsim[-2]:
                    sim[-1] = xr
                    fsim[-1] = fxr
                else:  # fxr >= fsim[-2]
                    # Perform contraction
                    if fxr < fsim[-1]:
                        xc = (1 + psi * rho) * xbar - psi * rho * sim[-1]
                        if bounds is not None:
                            xc = np.clip(xc, lower_bound, upper_bound)
                        # fxc = func(xc)
                        fxc = func(xc, args[0], args[1], args[2], args[3])

                        if fxc <= fxr:
                            sim[-1] = xc
                            fsim[-1] = fxc
                        else:
                            doshrink = 1
                    else:
                        # Perform an inside contraction
                        xcc = (1 - psi) * xbar + psi * sim[-1]
                        if bounds is not None:
                            xcc = np.clip(xcc, lower_bound, upper_bound)
                        # fxcc = func(xcc)
                        fxcc = func(xcc, args[0], args[1], args[2], args[3])

                        if fxcc < fsim[-1]:
                            sim[-1] = xcc
                            fsim[-1] = fxcc
                        else:
                            doshrink = 1
                    # shrink
                    if doshrink:
                        for j in one2np1:
                            sim[j] = sim[0] + sigma * (sim[j] - sim[0])
                            if bounds is not None:
                                sim[j] = np.clip(sim[j], lower_bound, upper_bound)
                            # fsim[j] = func(sim[j])
                            fsim[j] = func(sim[j], 
                                            args[0], 
                                            args[1], 
                                            args[2], 
                                            args[3])
            iterations += 1
            ind = np.argsort(fsim)
            sim = sim[ind]
            fsim = np.take(fsim, ind)
    #         sim = np.sort(sim)
    #         fsim = np.sort(fsim)

    x = sim[0]
    # x = x0
    return x
    # return sim, fsim

@jit(nopython=True)
def linespline_jit(signals,
                   responseArray, 
                   knots):
    """
    Jitted version of linespline(). See linespline().

    Parameters
    ----------
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    responseArray: numpy.ndarray
        DANTE channel responses as a function of photon energy (not 
        normalized). Must be a numpy array to work with Numba.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().

    Returns
    -------
    linespline : numpy.ndarray
        The resulting spline values that represent the average x-ray flux for
        the energy band between response k-edges.

    """
    chanNum = responseArray.shape[1]
    # integrate channel responses to build response matrix
    linesplineTab = np.zeros((chanNum-1, len(knots)-1))
    energy = responseArray[:, 0]
    for idx in range(0, chanNum-1):
        toIntegrate = responseArray[:, idx+1]
        for idx2 in range(0, len(knots)-1):
            lb = knots[idx2]
            rb = knots[idx2 + 1]
            uInterp = np.arange(lb, rb, 0.001)
            interpResp = np.interp(uInterp, energy, toIntegrate)
            integResponse = np.trapz(interpResp, uInterp)
            # interpResp = pchip_1d(energy, toIntegrate, uInterp)
            # integResponse = np.trapz(interpResp, uInterp)
            linesplineTab[idx, idx2] = integResponse
    # take the inverse of the integrated response matrix
    lineInverse = np.linalg.inv(linesplineTab)
    # take dot product and clip solution to positive values
    dotProd = np.dot(lineInverse, signals)
    linespline = np.clip(dotProd, 0, np.inf)
            
    return linespline

@jit(nopython=True)
def knotSolvePCHIP_jit(signals,
                       responseArray, 
                       knots,
                       initial = np.array([]),
                       xInterp = 'default'):
    """
    Jitted version of knotSolvePCHIP(). See knotSolvePCHIP().

    Parameters
    ----------
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    responseArray: numpy.ndarray
        DANTE channel responses as a function of photon energy (not 
        normalized). Must be numpy array for Numba.
    channels: list, numpy.ndarray
        List or array of relevant channels
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    initial : list, optional 
        The initial point used in the Nelder-Mead simplex. This initial value
        is calculated automatically via the linespline() function if left
        empty. The user is free to specify this initial point independently,
        but typically the guess won't be as good as the linear spline estimate.
        The default is [].
    xInterp : str, optional
        Specifies the number of points to be used in the PCHIP interpolation of
        knots (energies) and knotValues (fluxes). The default is 'default'.
    plot: Bool
        When True, plots the resulting PCHIP-interpolated x-ray flux. The 
        default is False.

    Returns
    -------
    knotsY : numpy.ndarray
        The y-values of the x-ray flux at each knot point (energy/k-edge 
        locations). Use these values as the y input and knots as the x
        input to the PCHIP interpolater to get the x-ray flux curve..

    """
    
    # solve linear spline first to provide seeding for Nelder-Mead simplex
    if len(initial) == 0:
        Linespline = linespline_jit(signals,
                                    responseArray,
                                    knots)
    else:
        print("use custom seed")
        Linespline = initial
    
    # initial point guess based upon initial linear spline point
    y0 = Linespline[0]*1e-1

    # list of bounds. Accept only physical soltuions (knotsY>0)
    bounds = np.array([(0, np.inf)]*len(signals))
    
    # run minimization using Nelder-Mead and scipy minimize function
    fiduciaSolve = neldermead(minFunc_jit,
                              Linespline,
                              args = (responseArray,
                                      knots,
                                      signals,
                                      y0,
                                      xInterp),
                              bounds = bounds)
    
    # return knot values from minimization
    init = np.array([y0])
    knotsY = np.concatenate((init, fiduciaSolve))
    
    return knotsY

def get_errors(channels):
    """
    Takes input channels and fetches the associated random and systematic
    errors associated with each channel. See the paper by K.M. Campbell et al.
    (https://doi.org/10.1063/1.1789603). Used to calculate error bars using
    Monte Carlo (see MC_jit()).

    Parameters
    ----------
    channels : list, numpy.ndarray
        List of channels used in the unfold.

    Returns
    -------
    get_rand : numpy.ndarray
        Array of random errors in order from channel 1 to 18.
    get_sys : numpy.ndarray
        Array of systematic errors in order from channel 1 to 18.

    """
    randErrors = np.array([7.8, 7.8, 18., 13.2, 8.3, 7.1, 7.1, 7.1, 7.1,
                            5.4, 5.4, 5.4, 5.4, 5.4, 5.4, 5.4, 5.4, 5.4])
    sysErrors = np.array([17.4, 8.2, 11.5, 6.0, 3.8, 2.3, 2.3, 2.3, 2.3,
                          2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3])
    get_rand = randErrors[np.array(channels)-1]
    get_sys = sysErrors[np.array(channels)-1]
    
    return get_rand, get_sys

def get_responses(responseFrame, channels):
    """
    Converts responseFrame into numpy arrays to read into jitted functions

    Parameters
    ----------
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    channels : list, numpy.ndarray
        List or array of relevant channels.

    Returns
    -------
    resp : numpy.ndarray
        The numpy array of the response functions for each channel. Must be
        used with jitted functions since Numba does not support Pandas.

    """
    responses = responseFrame[channels].to_numpy()
    energies = responseFrame["Energy(eV)"].to_numpy()
    energies = energies[:, None]
    resp = np.concatenate((energies, responses), axis = 1)
    
    return resp

@jit(nopython=True)
def checkFidelity_jit(responseArray,
                      photonEnergy,
                      intensity):
    r"""
    Integrate constructed spectrum with the response functions to check if the
    recovered cubic spline is self-consistent with the input Dante signals

    Parameters
    ----------
       
    responseArray: numpy.ndarray
        DANTE channel responses as a function of photon energy (not 
        normalized). Must be numpy array for Numba.
        
    photonEnergy: numpy.ndarray
        Photon energy axis of unfolded spectrum.
        
    intensity: numpy.ndarray
        Spectral intensity axis of unfolded spectrum.

    Returns
    -------
    fidelity : numpy.ndarray
        The recalculated voltage values from convolving the cubic spline
        solution with the Dante response functions.

    """
    
    responseEnergy = responseArray[:, 0]
    responseOnly = responseArray[:, 1:]
    chanNum = responseOnly.shape[1]
    
    # initialize fidelity to number of channel responses
    fidelity = np.zeros(chanNum) 
    
    #calculate fidelity by reconvolving solution with Dante responses
    for idx in range(chanNum):
        chanResponse = responseOnly[:, idx]
        responseInterp = np.interp(photonEnergy, responseEnergy, chanResponse)
        convolve = intensity*responseInterp
        fidelity[idx] = np.trapz(convolve, photonEnergy)
    return fidelity

def responseArrayMC(responseFrame, channels, randErrors, samples):
    """
    Generates a perturbed array of response functions based on the random
    errors associated with each Dante channel.

    Parameters
    ----------
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    channels: list, numpy.ndarray
        List or array of relevant channels.
    randErrors : numpy.ndarray
        Array of random errors in order from channel 1 to 18. See get_errors()
    samples : integer
        Number of samples to run for the Monte Carlo.

    Returns
    -------
    responseArrayMC : numpy.ndarray
        Array of response functions perturbed by the random error from each 
        Dante channel.

    """
    responseArray = get_responses(responseFrame, channels)
    responseArrayMCshape = ((samples),) + responseArray.shape
    responseArrayMC = np.empty(responseArrayMCshape)
    chanNum = len(channels)
    for idx in range(samples):
        responseArrayMC[idx, :, 0] = responseFrame["Energy(eV)"]
        for idx2 in range(chanNum):
            responseTest = responseArray[:, idx2 + 1]
            randNums = randErrors[idx2]*1e-2*responseTest
            
            # selects a random number for each element of the response array
            randResponse = np.random.normal(responseTest, randNums)
            
            # unused response multiplier for "systematic errors"
            # systematic errors are handled as errors on the voltage values
            # respMult = np.random.normal(0, sysErrors[chan - 1])*1e-2
            # responseFrameMC[chan] = randResponse*(1 + respMult)
            
            responseArrayMC[idx, :, idx2+1] = randResponse
            
    return responseArrayMC

@jit(nopython = True, parallel = False)
def MC_jit(responseArray,
           signals,
           knots,
           initial = np.array([])):  
    """
    Function for running Monte Carlo unfolds to calculate error bars for the
    x-ray unfolds. This should be called with run_MC_wrapper() in order to take
    advantage of jit speed. Otherwise you will grow old waiting for your error
    bars.

    Parameters
    ----------
    responseArray: numpy.ndarray
        DANTE channel responses as a function of photon energy (not 
        normalized). Must be numpy array for Numba.
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    initial : list, optional 
        The initial point used in the Nelder-Mead simplex. This initial value
        is calculated automatically via the linespline() function if left
        empty. The user is free to specify this initial point independently,
        but typically the guess won't be as good as the linear spline estimate.
        The default is [].

    Returns
    -------
    splineVals : numpy.ndarray
        The output from knotSolvePCHIP_jit(). Identical to knotsY. See 
        knotSolvePCHIP() and knotSolvePCHIP_jit().
    fidelityVals : numpy.ndarray
        The recalculated voltage values from convolving the cubic spline
        solution with the Dante response functions. Identical to fidelity from
        checkFidelity_jit().
    deltaVals : numpy.ndarray
        Difference between the output fidelityVals and input signals. These
        differences factor into the final calculation of the error bars.

    """
    # generate an interpolation array for pchip
    interpLen = responseArray.shape[0]*10
    xInterp = np.linspace(min(knots), max(knots), num = interpLen)
    
    # solve for knots with perturbed responseArray
    splineVals = knotSolvePCHIP_jit(signals,
                                    responseArray,
                                    knots,
                                    initial=initial)
    # generate the spline using the pchip interpolater
    pchipSpline = pchip_1d(knots, splineVals, xInterp)
    
    # reconvolve solution with the response functions and compare to inputs
    fidelityVals = checkFidelity_jit(responseArray,
                                     xInterp,
                                     pchipSpline)
    
    # calculate the difference between the reconvolution and data                                              
    deltaVals = fidelityVals - signals

    return splineVals, fidelityVals, deltaVals

def run_MC_wrapper(responseFrame,
                   signals, 
                   channels, 
                   knots, 
                   samples, 
                   initial=np.array([])):
    """
    Wrapper function for running the MonteCarlo error calculations to get error
    bars for the unfold. This wrapper takes advantage of MC_jit by calling it
    in a for loop in this function.

    Parameters
    ----------
    responseFrame: pandas.core.frame.DataFrame
        DANTE channel responses as a function of photon energy (not 
        normalized).
    signals : numpy.ndarray
        An array of voltage values at a specific time. Typically generated by
        the signalsAtTime function.
    channels: list, numpy.ndarray
        List or array of relevant channels.
    knots: list, numpy.ndarray
        List or array of knot point photon energy value. See knotFind().
    samples : integer
        Number of samples to run for the Monte Carlo.
    initial : list, optional 
        The initial point used in the Nelder-Mead simplex. This initial value
        is calculated automatically via the linespline() function if left
        empty. The user is free to specify this initial point independently,
        but typically the guess won't be as good as the linear spline estimate.
        The default is [].

    Returns
    -------
    splineVals : numpy.ndarray
        The output from knotSolvePCHIP_jit(). Identical to knotsY. See 
        knotSolvePCHIP() and knotSolvePCHIP_jit().
    fidVals : numpy.ndarray
        The recalculated voltage values from convolving the cubic spline
        solution with the Dante response functions. Identical to fidelity from
        checkFidelity_jit().
    deltaVals : numpy.ndarray
        Difference between the output fidelityVals and input signals. These
        differences factor into the final calculation of the error bars.

    """
    # initialize storage arrays
    splineVals = np.zeros((samples, len(channels)+1))
    fidVals = np.zeros((samples, len(channels)))
    deltaVals = np.zeros((samples, len(channels)))
    
    # get random errors from input channels
    randErrors, _ = get_errors(channels)
    
    # generate arrays of random responsed functions
    responseMC = responseArrayMC(responseFrame, 
                                 channels, 
                                 randErrors, 
                                 samples)
    for idx in range(samples):
        print(idx)
        responseArray = responseMC[idx]
        splineVals[idx], fidVals[idx], deltaVals[idx] = MC_jit(responseArray,
                                                               signals,
                                                               knots,
                                                               initial=initial)
    return splineVals, fidVals, deltaVals